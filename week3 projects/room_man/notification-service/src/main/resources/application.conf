kafka.bootstrap.servers = "localhost:9092"
kafka.enabled = true

kafka.consumer {
  group.id = "notification-service-group"
  auto.offset.reset = "earliest"
  enable.auto.commit = true
  auto.commit.interval.ms = 1000
  session.timeout.ms = 30000
  heartbeat.interval.ms = 3000
  max.poll.records = 500
  max.poll.interval.ms = 300000
}

kafka.topics {
  room.preparation = "room-preparation-notifications"
  reservation.reminder = "reservation-reminder-notifications"
  room.release = "room-release-notifications"
  admin.notifications = "admin-notifications"
}

email.smtp.host = "smtp.gmail.com"
email.smtp.port = 587
email.smtp.user = "rohanbold123@gmail.com"
email.smtp.password = "xikh mllb jqmj bdgk"
email.from = "rohanbold123@gmail.com"
email.smtp.user = ${?EMAIL_USER}
email.smtp.password = ${?EMAIL_PASSWORD}

akka {
  loglevel = "INFO"

  actor {
    provider = "akka.actor.typed.ActorSystemProvider"

    default-dispatcher {
      type = Dispatcher
      executor = "fork-join-executor"
      fork-join-executor {
        parallelism-min = 8
        parallelism-factor = 3.0
        parallelism-max = 64
      }
      throughput = 1
    }

    kafka-dispatcher {
      type = Dispatcher
      executor = "thread-pool-executor"
      thread-pool-executor {
        fixed-pool-size = 16
      }
      throughput = 1
    }
  }

  stream {
    materializer {
      initial-input-buffer-size = 4
      max-input-buffer-size = 16
    }
  }

  kafka {
    consumer {
      kafka-clients {
        bootstrap.servers = ${kafka.bootstrap.servers}
        group.id = ${kafka.consumer.group.id}
        auto.offset.reset = ${kafka.consumer.auto.offset.reset}
        enable.auto.commit = ${kafka.consumer.enable.auto.commit}
        auto.commit.interval.ms = ${kafka.consumer.auto.commit.interval.ms}
        session.timeout.ms = ${kafka.consumer.session.timeout.ms}
        heartbeat.interval.ms = ${kafka.consumer.heartbeat.interval.ms}
        max.poll.records = ${kafka.consumer.max.poll.records}
        max.poll.interval.ms = ${kafka.consumer.max.poll.interval.ms}
      }

      stop-timeout = 30s
      close-timeout = 20s
      commit-timeout = 15s
      wakeup-timeout = 3s
      max-wakeups = 10

      commit-refresh-interval = 1s
    }
  }
}

notification.service {
  parallelism = 4
  buffer.size = 1000
  restart.delay.seconds = 5
  max.retries = 3
  batch.size = 10
}

logging {
  level = "INFO"
  pattern = "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
}
